"""
This type stub file was generated by pyright.
"""

__license__ = ...
class dom_tag:
  is_single = ...
  is_pretty = ...
  is_inline = ...
  def __new__(_cls, *args, **kwargs): # -> (*args: Unknown, **kwargs: Unknown) -> (Unknown | dom_tag) | Any:
    '''
    Check if bare tag is being used a a decorator
    (called with a single function arg).
    decorate the function and return
    '''
    ...
  
  def __init__(self, *args, **kwargs) -> None:
    '''
    Creates a new tag. Child tags should be passed as arguments and attributes
    should be passed as keyword arguments.

    There is a non-rendering attribute which controls how the tag renders:

    * `__inline` - Boolean value. If True renders all children tags on the same
                   line.
    '''
    ...
  
  frame = ...
  _with_contexts = ...
  def __enter__(self): # -> dom_tag:
    ...
  
  def __exit__(self, type, value, traceback): # -> None:
    ...
  
  def __call__(self, func): # -> (*args: Unknown, **kwargs: Unknown) -> (Unknown | dom_tag):
    '''
    tag instance is being used as a decorator.
    wrap func to make a copy of this tag
    '''
    ...
  
  def set_attribute(self, key, value): # -> None:
    '''
    Add or update the value of an attribute.
    '''
    ...
  
  __setitem__ = ...
  def delete_attribute(self, key): # -> None:
    ...
  
  __delitem__ = ...
  def setdocument(self, doc): # -> None:
    '''
    Creates a reference to the parent document to allow for partial-tree
    validation.
    '''
    ...
  
  def add(self, *args): # -> tuple[Unknown, ...]:
    '''
    Add new child tags.
    '''
    ...
  
  def add_raw_string(self, s): # -> None:
    ...
  
  def remove(self, obj): # -> None:
    ...
  
  def clear(self): # -> None:
    ...
  
  def get(self, tag=..., **kwargs): # -> list[Unknown]:
    '''
    Recursively searches children for tags of a certain
    type with matching attributes.
    '''
    ...
  
  def __getitem__(self, key): # -> Any:
    '''
    Returns the stored value of the specified attribute or child
    (if it exists).
    '''
    ...
  
  __getattr__ = ...
  def __len__(self): # -> int:
    '''
    Number of child elements.
    '''
    ...
  
  def __bool__(self): # -> Literal[True]:
    '''
    Hack for "if x" and __len__
    '''
    ...
  
  __nonzero__ = ...
  def __iter__(self): # -> Iterator[Unknown]:
    '''
    Iterates over child elements.
    '''
    ...
  
  def __contains__(self, item): # -> bool:
    '''
    Checks recursively if item is in children tree.
    Accepts both a string and a class.
    '''
    ...
  
  def __iadd__(self, obj): # -> dom_tag:
    '''
    Reflexive binary addition simply adds tag as a child.
    '''
    ...
  
  def __unicode__(self): # -> str:
    ...
  
  __str__ = ...
  def render(self, indent=..., pretty=..., xhtml=...): # -> str:
    ...
  
  def __repr__(self): # -> str:
    ...
  
  @staticmethod
  def clean_attribute(attribute): # -> str:
    '''
    Normalize attribute names for shorthand and work arounds for limitations
    in Python's syntax
    '''
    ...
  
  @classmethod
  def clean_pair(cls, attribute, value): # -> tuple[str | Unknown, str | Unknown]:
    '''
    This will call `clean_attribute` on the attribute and also allows for the
    creation of boolean attributes.

    Ex. input(selected=True) is equivalent to input(selected="selected")
    '''
    ...
  


_get_current_none = ...
def get_current(default=...):
  '''
  get the current tag being used as a with context or decorated function.
  if no context is active, raises ValueError, or returns the default, if provided
  '''
  ...

def attr(*args, **kwargs): # -> None:
  '''
  Set attributes on the current active tag context
  '''
  ...

